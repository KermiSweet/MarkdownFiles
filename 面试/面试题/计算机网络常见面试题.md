# NO1 – Http和Https

## 1 基本概念

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，**简单讲是HTTP的安全版，即HTTP下加入SSL层**，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

## 2 区别

Http协议运行在TCP之上，即明文传输，客户端和服务器端都无法验证对方的身份；
Https是身披SSL（Secure Socket Layer）外壳的Http，运行于SSL上，SSL运行于TCP之上，**是添加了加密和认证机制的HTTP。**
二者存在的不同主要有以下几点：

- **（1） 端口不同**
  Http和Https使用的是不同的连接方式，用到的端口也不一样，Http是80，Https是443
- **（2）资源消耗**
  Http是超文本传输协议，信息是明文传输，Https则是具有安全性的ssl加密传输协议。和Http通信相比，**Https通信会由于加减密处理消耗更多的CPU和内存资源**。
- **（3）成本开销**
  Https协议需要用到CA申请证书，一般免费的较少，因此需要一定的费用向认证机构购买
- **（4）安全性能**
  Http的连接很简单，是无状态的；**HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全**。

Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

## 3 HTTP长连接、短连接

在HTTP/1.0中默认使用短连接。
也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如javaScript文件、图像文件、CSS文件等），
每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。
使用长连接的HTTP协议，会在响应头加入这行代码：

```java
Connection：keep-alive
1
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭
客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。
Keep-alive 不会永久保持连接，它会保持一个时间，可以在不同的服务器软件（如Apache）中设定时间。
实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短链接， 实质是TCP协议的长连接和短连接。**

# NO2 – 对称加密和非对称加密

## 1 基本概念

- 对称加密是指加密和解密**使用的是同一个密钥**的方式。
  这种方法存在的最大问题就是密钥发送问题，即如何将密钥安全的发给对方，密钥在网络中传输，安全性不高
- 非对称加密是指**使用的是一对非对称的密钥**的方式，它使用了一对密钥，公钥（public key）和私钥（private key）。
  公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

## 2 加密方法

由于非对称加密的方式 不需要发送用来解密的私钥，所以可以保证安全性；
但是和对称加密比起来，它非常的慢，
所以我们还是**要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式 发送出去。**

# NO3 – 从输入网址到获得页面的过程

- **（1）域名解析，其实就是根据用户输入的网址去寻找它对应的IP地址**
  浏览器查询DNS，获取域名对应的IP地址
- **（2）建立TCP连接**
  浏览器获得域名对应的IP地址后，浏览器向服务器请求建立链接，TCP/IP 链接建立起来后，浏览器向服务器发送HTTP请求
- **（3）根据SpringMVC后台业务返回数据，并把数据填充到HTML页面上，然后返回给浏览器**
  服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理
- **（4）浏览器进行处理**
  浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源
- **（5）绘制网页**
  浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面

## 浏览器解析DNS的过程

（1）域名解析，其实就是根据用户输入的网址去寻找它对应的IP地址，比如输入www.baidu.com的网址就会经历以下过程

1.先从浏览器缓存里找IP,因为浏览器会缓存DNS记录一段时间

2.如没找到,再从Hosts文件查找是否有该域名和对应IP

3.如没找到,再从路由器缓存找

4.如没好到,再从DNS缓存查找

5.如果都没找到,浏览器域名服务器向根域名服务器(baidu.com)查找域名对应IP,还没找到就把请求转发到下一级,直到找到IP
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519215003101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 过程及其使用的协议

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200519214642408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

# NO-4 TCP中的拥塞控制

计算机网络中的带宽、交换节点中的缓存及处理机等都是网络的资源。
在某段时间里，若对网络中某一资源的需求超过了该资所能提供的可用部分，网络的性能就会变坏，这种情况就叫做阻塞。
拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。
注意：**拥塞控制和流量控制的不同，前者是一个全局性的过程，而后者指点对点通信量的控制。**

## 1 慢启动

不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小

## 2 拥塞避免

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524213553435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 3 快重传

快重传要求接收方在收到一个**失序的报文段**后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。
快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524214010568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 4 快恢复

快重传配合使用的还有快恢复方法，
当发送方连续收到三个重复确认时，就执行“乘法减小” 算法，把ssthresh门限减半，但是接下来并不执行慢开始算法
因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以放发送现在认为网络可能没有出现拥塞，所以现在不执行慢开始算法
而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524214351244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

# NO-5 OSI网络体系结构与TCP/IP协议模型

## 0 体系结构图

TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际的网络通信标准。
但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样互相准确理解对方的意思并作出优雅的回应。
学习计算机网络我们采取的是折中的办法，采取的是一种只有五层协议的体系结构。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525105747699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 1 物理层（physical layer）

在物理层上所传送的数据单位是比特。
参考模型的最底层，**作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异，**使其上面的数据链路层不必考虑网络的传输介质是什么。

“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

## 2 数据链路层（data link layer）

数据链路层`负责两台主机之间的数据传输`，**接收来自物理层的位流形式的数据并封装成帧，传送到上一层；同样，也将来自上层的数据帧帧拆分成位流形式的数据，转发到物理层。（在两个相邻节点的链路上传送帧。）** 数据链路层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理链路变为无差错的数据链路，（不仅要检错还要纠错）**即提供可靠的通过物理介意传输数据的方法。**

## 3 网络层（network layer）

网络层`负责为不同主机提供逻辑通信服务`，并**通过路由选择算法为分组通过通信子网选择最适当的路径**。
在发送数据时，网络层把传输层产生的报文段或用户数据包封装成分组和包进行传送。
在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525112538829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 4 传输层 （transport layer）

传输层的主要任务就是`负责两台主机进程之间的通信提供通用的数据传输服务。`
在源端和目的端之间提供可靠的透明数据传输，使上层服务用户不必关心通信子网的实现细节。

> “通用的”是指并不针对某一特定的网络应用，而是多种应用可以使用同一个运输层服务。
> 由于一台主机可同时运行多个线程，因此传输层用复用和分用的功能。
> 所谓复用就是指多个应用层进程可同时使用下面运输层的服务
> 分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

**在协议栈中，传输层位于网络层之上，传输层协议为不同主机上的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525113010270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 5 应用层

应用层的任务是**通过应用进程间的交互来完成特定网络应用**。
应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。
在互联网中，应用层协议有很多，如**域名系统DNS，**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等。
我们把应用层交互的数据单元成为报文。

- 域名系统

> 域名系统(Domain Name System缩写 DNS，DomainName被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）
> 例如：一个公司的Web网站可看作是它在网上的门户，而域名就相当于其门牌地 址，通常域名都使用该公司的名称或简称。
> 例如上面提到的微软公司的域名，类似的还有：IBM公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是www.cisco.com 等。

- HTTP协议

> 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。
> 所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）

## 6 TCP和UDP分别对应的常见应用层协议

**TCP对应的常见应用层协议**

- FTP：定义了文件传输协议，使用21端口
  常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
- Telnet：它是一种用于远程登陆的端口
  用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。
  如以前的BBS是纯字符界面的，支持BBS的服务器将**23端口**打开，对外提供服务。
- SMTP：定义了简单邮件传送协议
  现在很多邮件服务器都用的是这个协议，用于发送邮件。
  如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常见到有SMTP端口设置这一栏，服务器开放的是**25端口**
- POP3：它是和SMTP对应，POP3用于接收邮件
  通常情况下，POP3协议所用的是**110端口**。
  也就是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进网易网站，再进入自己的邮箱来收信）

**UCP对应的常见应用层协议**

- DNS： 用于域名解析，将域名地址转换为IP地址。DNS用的是**53端口**
- SNMP：简单网络管理协议，使用**161端口**，是用来管理网络设备的
  由于网络设备很多，无连接的服务就体现出其优势
- TFTP（Trival File Transfer Protocal ）：简单文件传输协议
  该协议在熟知端口**69端口**使用UDP服务。

**图示：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527142647950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 7 网络层的地址解析协议ARP协议

ARP(地址解析协议)：该协议可以把网络层IP32位地址转化为数据链路层MAC48位地址。
网络层的ARP **完成了IP地址与物理地址的映射。**

- **ARP协议的工作过程**
  第一步，首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。

------

第二步，当源主机需要将一个数据包要发送到目的主机时：
会首先检查自己的ARP列表中是否存在该IP地址对应的MAC地址：
如果有，就直接将这个数据包发送到这个MAC地址；
如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址
此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址

------

第三步， 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。
如果不相同直接忽略，
如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，
如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址

------

第四步，源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输
如果源主机一致没有收到ARP响应数据包，表示ARP查询失败

------

ARP缓存表：IP地址-MAC地址映射表。 ARP缓存表是ARP协议和RARP协议运行的关键；
ARP缓存表缓存了IP地址到硬件地址之间的映射关系；
ARP缓存表中的记录并不是永久有效的，有一定的期限，因为**IP地址是不断变化的**。

**查询ARP表会出现两种情况：**

- ARP缓存表缓存有 IP地址和MAC地址的映射关系：
  发送端可以 直接告知自身的数据链路层目的MAC地址。
- ARP缓存表没有缓存IP地址和MAC地址的映射关系：
  向除了接受的数据报的发送者意外广播信息，接收到回信记录对应的地址。

广播发送ARP请求，单播发送ARP响应。

# NO-6 客户端不断进行请求链接会怎样？DDOS（Distributed Denial of Service）攻击?

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

## 1 DDoS攻击

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

## 2 DDoS预防 （没有彻底根治的方法，除非不使用TCP）

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务

# NO-7 Get 与POST的区别

Get与POST是我们常用的HTTP Method, 二者的区别主要表现在如下五个方面:

- (1) 从功能上讲,
  Get一般用来从服务器上**获取资源**, POST一般用来**更新服务器上的资源.**
- (2) 从REST服务角度上来说,
  GET是**幂等**的,即读取同一个资源,总是得到相同的数据,
  而POST**不是幂等的**,为每次请求对资源的改变并不是相同的;进一步的,Get不会改变服务器上的资源,而POST会对服务器资源进行改变.
- (3) 从 请求参数形式上来看,
  Get请求的数据会附在URL之后,即将请求数据放在**HTTP报文的请求头中**,以? 分割URL和传输数据,参数之间以&相连
  而POST请求会把提交的数据则放置在是HTTP请求报文的**请求体中**
- (4) 就安全性而言
  POST的安全性要比GET的安全性高,因为Get请求提交的数据将**明文出现在URL上**, 而且POST请求参数则被包装到**请求体中**,相对更安全
- (5) 从请求的大小看
  GET请求的长度受限于**浏览器或服务器对URL长度的限制**,允许发送的数据量比较小,
  而POST请求则是没有大小限制的

> GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。
> 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
> 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。

## NO-8 Session、Cookie与Application

Cookie和Session 都是客户端与服务器**保持状态**的解决方法,具体来说, Cookie机制采用的是在**客户端**保持状态的方案,而Session 机制采用的是在**服务器端**保持状态的方案.

## 1 Cookie

Cookie实际上是一小段的文本信息.
客户端请求服务器,如果服务器需要记录该用户状态,就使用response向客户端浏览器颁发一个Cookie,而客户端浏览器会把Cookie保存起来.
当浏览器再请求该网站时, 浏览器把请求的网址连同该Cookie一同提交给服务器,服务器检查该Cookie,以此来辨认用户状态.
服务器还可以根据需要修改Cookie的内容

## 2 Session

同样的,会话状态也可以保存在服务器端.
客户端请求服务器,如果服务器记录该用户状态,就获取Session来保存状态
此时,如果服务器已经为此客户创建过Session,服务器就按照Sessionid把这个Session检索出来使用
如果客户端请求不包含Sessionid,则为此客户端创建一个Session并且生成一个与此Session相关联的Sessionid,并将这个Sessionid在本次相应中返回给客户端保存

保存这个Sessionid的方式可以采用cookie机制,这样在交互的过程中浏览器可以自动的按照规则把这个标识发送给服务器,
若浏览器禁用Cookie的话,可以通过**URL重写机制**将Sessionid传回服务器.

## 3 Cookie和Session的对比

- (1) 实现机制
  Session的实现常常依赖于Cookie机制,通过Cookie机制回传SessionID
- (2)大小限制
  Cookie有大小限制并且浏览器对每个站点也有Cookie的个数限制;,Session没有大小限制,理论上只与服务器的内存大小有关
- (3) 安全性
  Cookie存在安全隐患,通过拦截或本地文件找到Cookie后可以进行攻击,而Session 由于保存在服务器端,相对更加安全
- (4) 服务器资源消耗
  Session 是保存在服务器端上会存在一段时间才会小时,如果Session过多会增加服务器的压力

## 4 Application

Application(java Web 中的ServletContext) :与一个Web应用程序相对应,为应用程序提供了一个全局的状态,所有客户都可以使用该状态。

# NO-9 SQL注入

SQL注入是目前黑客最常用的攻击手段，它的原理是利用数据库对特殊标识符的解析强行从页面向后台传入。改变SQL语句结构，达到扩展权限、创建高等级用户、强行修改用户资料等等操作。
SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

## 1 SQL注入攻击的总体思路

（1）寻找SQL注入的位置
（2）判断服务器类型和后台数据库类型
（3）针对不同的服务器和数据库特点进行SQL注入攻击

## 2 SQL注入攻击实例

比如在一个登录界面，要求输入用户名和密码：

可以这样输入实现免帐号登录：

用户名： ‘or 1 = 1 –

密 码：

点登陆,如若没有做特殊处理,那么这个非法用户就很得意的登陆进去了.(当然现在的有些语言的数据库API已经处理了这些问题)

这是为什么呢? 下面我们分析一下：

从理论上说，后台认证程序中会有如下的SQL语句：

String sql = "select * from user_table where username=

’ “+userName+” ’ and password=’ “+password+” '";

当输入了上面的用户名和密码，上面的SQL语句变成：

**SELECT \* FROM user_table WHERE username=
‘’or 1 = 1 – and password=’’**

分析SQL语句：

**条件后面username=”or 1=1 用户名等于 ” 或1=1 那么这个条件一定会成功；
然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用，这样语句永远都能正确执行，用户轻易骗过系统，获取合法身份。**

这还是比较温柔的，如果是执行

SELECT * FROM user_table WHERE

username=’’ ;DROP DATABASE (DB Name) --’ and password=’’

….其后果可想而知…

> 原文链接：https://blog.csdn.net/hxpjava1/article/details/81011334

## 3 应对方法

- （1）参数绑定，使用预编译语句
  **使用预编译手段，绑定参数是最好的防SQL注入的方法。**
  目前许多的ORM框架及JDBC等都实现了SQL预编译及参数绑定功能，攻击者的恶意SQL会被当作SQL的参数而不是SQL命令被执行。
  在mybatis的mapper稳健者，对于传递的参数我们一般是使用#和KaTeX parse error: Expected 'EOF', got '#' at position 12: 来获取参数值。 当使用#̲时，变量是占位符，就是一般我们…时，变量就是直接追加在sql中，一般会有sql注入问题
- （2） 使用正则表达式过滤传入的参数
- （3） 检查变量数据类型和格式
  只要是固定格式的变量，在SQL语句执行前，应该严格按照固定格式检查，确保变量是我们预想的格式！

# NO-10 XSS攻击

XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。
XSS全称cross-site scripting（跨站点脚本），是当前 web 应用中最危险和最普遍的漏洞之一。攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，携带木马等等

XSS是指恶意攻击者利用**网站没有对用户提交数据进行转移处理或者过滤不足的缺点，** 进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

## 1 XSS攻击的危害

盗取各类的用户账号，如及其登陆账号、用户网银账号、各类管理账号
控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
盗窃企业重要的具有商业价值的资料
非法转账
强制发送电子邮件
网站挂马
控制受害者机器向其他网站发起攻击

## 2 XSS攻击发生的原因解析

**主要原因：过于信任客户端提交的数据**
解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作

进一步分析细节：
客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮的展开攻击啦，**因此我们绝不可以信任任何客户端提交的数据**

## 3 XSS攻击分类

- （1） 反射性XSS攻击（非持久性XSS攻击）
  漏洞产生的原因是攻击者注入的数据反映在响应中。

利用网站某些页面会直接输出请求参数的特性，通过在url的请求参数包含恶意脚本,诱使用户点击嵌入恶意脚本的url链接执行恶意脚本以达到攻击的目的。目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式。

一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接（即每次攻击需要用户的点击）。
例如，正常发送消息：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527111202224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

- （2）存储型XSS（持久性XSS攻击）
  XSS攻击向量（一般指XSS攻击代码）存储在网站数据库，当一个页面被用户打开的时候执行。
  也就是说，每个用户使用浏览器打开指定页面时，脚本便执行。
  与非持久性XSS攻击相比，持久性XSS攻击危害性更大，
  从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中 ，然后客户端打开时就执行这些攻击代码。

通过表单输入（比如发布文章、回复评论等功能中）插入一些恶意脚本，并且提交到被攻击网站的服务器数据库中。
当用户浏览指定网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台。
与反射型 XSS 相比，该类的攻击更具有危害性，因为它影响的不只是一个用户，而是大量用户，而且该种类型还可进行蠕虫传播。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527111826612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

-（3）DOM Based XSS（基于 dom 的跨站点脚本攻击）
通过前面两种类型的方式，注入的脚本是通过改变 DOM 来进行攻击的。采用该种方式有一个好处就是从源代码中不易被发现。

## 4 XSS攻击防护防范

防范xss攻击的原则就是不相信用户输入的数据，我们可以从俩方面入手：

（1）消毒（对危险字符进行转义）
（2）HttpOnly（防范XSS攻击者窃取Cookie数据）。

- 消毒
  **对数据进行转义**，比如<转义成<,这样脚本就运行不了了
  **录入数据设置白名单**，比如javaWeb项目，设置过滤器过滤特殊字符
  **前端页面限制用户输入数据类型**，比如用户输入完年龄后验证输入内容只能是数字。
  **过滤JS事件的标签**，比如onclick、load等
- HttpOnly
  将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了

> 版权声明：这一段是参考CSDN博主「卜可」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/q649381130/article/details/79571574

# NO-11常见的状态码及原因短语

HTTP请求结构：请求方式+请求URL+协议及其版本
HTTP响应结构：状态码 + 原因短语 +协议及其版本

- 1** ：请求处理中，请求已被接受，正在处理
- 2**：请求成功，请求被成功处理
- 3**：重定向，要完成请求必须进一步处理
  301: 永久性转移
  302:暂时性转移
  304:已缓存
- 4**：客户端错误，请求不合法
  400 ：Bad Request，请求有语法问题
  403：拒绝请求
  404：客户端访问的页面不存在
- 5**：服务器端错误，服务器不能处理合法请求
  500：服务器内部错误
  503：服务不可以，稍等

# NO-11 IP地址的分类

IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，
它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

IP地址编址方案将IP地址空间划分为A，B，C，D，E五类，其中A，B，C是基本类，D，E作为多播和保留使用，为特殊地址。

每个IP地址包括两个标识码（ID）即网络ID和主机ID。
同一个物理网络上的所有主机都使用同一个网络ID，
网络上的一个主机（包括网络上的工作站，服务器和路由器等）有一个主机ID与其对应。

A~~E类地址的特点如下：

- A类地址：以0开头，第一个字节范围：0-127；
- B类地址：以10开头，第一个字节范围：128-191
- C类地址：以110开头，第一个字节范围：192-223
- D类地址：以1110开头，第一个字节范围：224-239
- E类地址：以1111开头，保留地址

## A类地址：1字节的网络地址+3字节的主机地址，网络地址的最高位必须是“0”

一个A类IP地址是指，在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码
如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”

A类IP地址中网络的标识长度为8位，主机标识的长度为24位，
A类网络地址数量较少，有126个网络，每个网络可容纳主机数达1600多万台

A类地址的地址范围1.0.0.0–127.255.255.255，最后一个是广播地址
（二进制表示为二进制表示为：0000000100000000 00000000 00000001 - 01111110 11111111 11111111 11111110））
A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方 = 16777214台。

## B类地址：2字节的网络地址 + 2字节的主机地址，网络地址的最高位必须是“10”

一个B类地址是指，在IP地址的四段号码中，前两段号码为网络号码，剩下的两段号码为本地计算机的号码
如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节的主机地址组成，网络地址的最高位必须是“10”

B类IP地址中网络的标识长度为16位，主机标识的长度位16位，
B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的主机数为6万多台

B类地址的地址范围128.0.0.0 – 191.255.255.255，最后一个是广播地址
（二进制表示为：1000000000000001 00000000 00000001 - 10111111 11111110 11111111 11111111）
B类IP地址的子网掩码为255.255.0。0，每个网络支持的最大主机数为256的2次方 - 2 = 65534 台

## C 类地址：3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”

一个C类地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。
如果用二进制表示IP地址的话，C类地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”

C类地址中网络的表示长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209余万个网络，
适用于小规模的局域网络，每个网络最多只能包含254台计算机。**C类IP地址是局域网最常用的类型.**

C类地址的地址范围192.0.0.0 – 223.255.255.255
（二进制表示为: 1100000000000000 00000001 00000001 - 11011111 11111111 11111110 11111111）
C类IP地址的子网掩码为255.255.255.0， 每个网络支持的最大主机数为256 - 2 = 254台

## D类地址：多播地址，用于1对多通信，最高位必须是“1110”

D类IP地址在历史上被叫做多播地址（multicast address），即组播地址。
在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。
多播地址的最高位必须是“110”，范围从224.0.0.0 – 239.255.255.255

D类地址用于多点广播（Multicast）。

D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。

D类地址多为操作系统使用.

## E类地址：为保留地址，最高位必须是“1111”