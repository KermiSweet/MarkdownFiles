# NO-1 线程和进程的区别和联系

## 1 定义

- **进程**
  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。（包括程序段，相关数据段和进程控制块PCB）
- **线程**
  线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与属于同一个进程的其他进程共享进程所拥有的全部资源。

## 2 关系

一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

## 3 区别

如果说操作系统引入进程的目的是为了提高程序并发执行，以提高资源利用率和系统吞吐量。那么操作系统中引入线程的目的，则是为了减少进程并发执行过程中所付出的时空开销，使操作系统能很好的并发执行。

进程process定义了一个执行环境，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个控制流，有他自己的调用栈call stack，记录了它的执行历史。

线程由两个部分组成：
　　1）线程的内核对象，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。
　　2）线程堆栈，它用于维护线程在执行代码时需要的所有参数和局部变量。当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529101545719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)
进程和线程的主要差别在于它们是不同的操作系统**资源管理方式**
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它线程产生影响。

而线程只是一个进程中的不同**执行路径**
线程有自己的堆栈和局部变量，但线程之间没有独特的地址空间，一个线程死掉就等于整个进程死掉，所以**多进程的程序比金线程的程序健壮。**

但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行又要共享某些变量的并发操作，**只能用线程，不能用进程。**

**总结：**

- **进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的兵法**
- **线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发**
- **一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在**
- **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**

从逻辑角度来看，多线程的意义存在于一个应用程序中，有多个执行部分可以同时执行。
但操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。
这就是进程和线程的重要区别。

## 4 优缺点

线程开销小，但不利于资源的管理 和保护； 进程与之相反。

# NO- 2 进程的常见状态？以及各种状态之间的转换条件？

- 就绪状态：进程已处于**准备好**运行的状态，即进程已分配到除CPU外的所以必要资源后，只要再获得CPU，便可立即执行。
- 运行状态：进程已获得CPU，程序正在执行状态
- 阻塞状态：正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时**无法继续执行**的状态

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529102410231.png)

# NO-3 进程间通信有哪些方式？它们的区别？

参考：https://www.cnblogs.com/inception6-lxc/p/9073983.html
进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。

高级通信机制可归结为三大类：

（1）共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

（2）消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。

（3）管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。

## 1 七种进程间通信方式

参考：https://blog.csdn.net/xiongluo0628/article/details/81461053
**IPC方式：7种**

- 1 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在有血缘关系的进程间使用，进程的血缘关系是指父子进程关系
- 2 命名管道（named pipe）： 也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
- 3 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生
- 4 信号量（semophere）：信号量是一个计数器，可用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源，其它进程也访问该资源。
  因此，**主要作为进程间以及同一进程内不同线程之间的同步手段。**
- 5 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递消息少，缓冲区有限的缺点。
  具有写权限的进程可以按照一定的规则向消息队列中添加新消息；对消息队列有读权限的进程可以从消息队列中读取信息。
- 6 共享内存（shared memory）：** 可以说这是最有用的进程间通信方式。**就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但多个进程都可以访问，不同进程可以即使看到对方进程中对共享内存中数据的更新。**共享内存是最快的IPC方式。**它是针对其它进程间的通信方式运行效率低而专门设计的。这种方式往往需要依赖某种同步操作，如互斥锁和信号量等。
- 7 套接字（socket）：这是一种更为一般的进程间通信机制，它可用于**网络中不同机器之间** 的进程间通信，应用非常广泛。

## 2 通信方式的比较

- 管道：速度慢，容量有限
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
- 信号量：不能传递复杂信息，只能用来同步
- 共享内存：能够很容易的控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写问题，相当于线程中的线程安全。

## 3 进程同步与互斥的区别

**互斥**：指某一个资源同时只允许一个访问者对其进行访问，具有唯一性和排他性。
但互斥无法限制访问者对资源的访问顺序，即访问是无序的

**同步**：是指在互斥的基础上（大多数情况下），通过其它机制实现访问者对资源的有序访问。
大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

**同步**：体现的是一种协作性
**互斥**：体现的是排他性

**进程同步的主要任务**
是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。

**同步机制遵循的原则**：
（1）空闲让进
（2）忙则等待
（3）有限等待
（4）让权等待

**进程间同步的主要方法**
有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等。

------

# NO-4 线程都有哪些状态？具体是怎么运行的

线程有：创建、就绪、运行、阻塞、终止 五种状态。

- （1） 新生状态
  在程序中用构造方法（new操作符）创建一个新线程时，如new Thread（r），该线程就是创建状态，此时它已经有了相应的内存空间和其它资源，**但是还没有开始执行。**
- （2）就绪状态
  新建线程对象后，调用该线程的start（）方法就可以启动线程。**当线程启动时，线程就进入就绪状态（runnable）**
  由于还没有分配CPU，线程将进入线程队列排队，等待CPU服务，这表明它已经具备了运行条件。
  当系统挑选一个等待执行的Thread对象后，它就会从等待状态进入执行状态。系统挑选的动作称之为“CPU调度”。
  一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。
- （3）运行状态
  当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run（）方法。
  run（）方法定义了该线程的操作和功能。运行状态中的线程执行自己的run方法中的代码，直到调用其它方法或者发生阻塞而终止。
- （4）阻塞状态
  一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入输出操作时，将让出CPU并暂时中止自己的执行，进入堵塞状态。

在可执行状态下，如果调用sleep（）、suspend（）、wait（）等方法，线程都将进入阻塞状态。
堵塞时，线程不能进入排队队列，只能当引起阻塞的原因被消除后，线程转入就绪状态，重新到就绪队列中排队等待，这时被CPU调度选中后会从原来停止的位置开始继续执行。

**记住：阻塞被消除后是回到就绪状态，不是运行状态。**

- （5）死亡状态
  线程调用stop（）方法，destory（）方法或run（）方法执行结束后，线程即处于死亡状态。
  处于死亡状态的线程不具有继续运行的能力。可以通过getState（）方法来获取线程当前的状态。

> 有的还有个超时等待
> 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期的等待被其它线程显式的唤醒，在达到一定时间之后它们会自动唤醒。

## 2 线程运行过程

a）调用new关键字创建后，进入到新生状态
b）调用start后进入就绪状态
c）CPU调度到本线程后，本线程开始执行，进入到运行状态
d）运行中遇到join，yield，sleep造成阻塞，进入阻塞状态。阻塞完成后，又回到就绪状态
e）线程正常执行完，或者遇到异常终止后，进入死亡状态。

# NO-5 线程间的通信机制及其通信方式（线程同步）

## 1 线程间的通信机制

- （1）锁机制：互斥锁、 条件变量、读写锁
  互斥锁提供了以排他方式防止数据结构并发修改的方法
  读写锁允许多个线程同时读共享数据，而对写操作是互斥的
  条件变量可以以原子的方式进行阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。 **条件变量始终与互斥锁一起使用。**
- （2）信号量机制：包括无名信号量和命名线程信号量
- （3） 信号机制：类似进程间的信号处理

**线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。**

## 2 线程间通信的方式

线程同步的方式：临界区、互斥量、信号量、信号（事件）

- （1） 临界区：
  通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

-（2）互斥量 Synchronized/Lock
采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

- （3）信号量 Semphare
  为控制具有有限数量的用户资源而设计的，它允许多个线程多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
- （4）事件（信号），Wait/Notify：
  通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

# NO-6 操作系统中进程调度策略有哪几种？

- （1） 先来先服务（FCFS）（队列实现，非抢占的）
  先请求CPU的进程先分配到CPU
  此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序选择作业（或进程）
- （2）最短作业优先调度算法（SJF：Shortest Process First）：
  平均等待时间最短，但难以知道下一个CPU区间长度
  这种算法主要用于作业调度，它从作业后备序列中挑选所需运行时间最短的作业进入主存运行。
- （3）优先级调度算法（可以是抢占的，也可以是非抢占的）
  优先级越高 越先分配到CPU，相同优先级 先到先服务。
  按照进程的优先权大小来调度，使高优先权进程得到优先处理的调度策略称为优先权调度算法。注意：优先数越多，优先权越小。

存在的主要问题：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿
解决方案：老化

- （4）时间片轮转调度算法（可抢占的）
  队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

当某个进程执行的时间片用完时，调度程序便终止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。
然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
这样就可以保证队列中的所有进程，在已给定的时间内，均能获得一时间片处理机执行时间。

- （5） 多级队列调度算法
  将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。
  其中，一个进程根据自身属性被永久分配到一个队列中。
- （6）多级反馈队列调度算法
  与多级队列调度算法相比，其允许进程在队列之间移动；
  若进程使用过多CPU时间，那么它会被转移到耕地的优先级队列；
  在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿的发生

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529210118315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529210130347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

> 非抢占式调度与抢占式调度
> 非抢占式：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度某事件而阻塞时，才把处理机分配给另一个进程
> 抢占式：操作系统将正在运行的进程强制暂停，由调度程序将CPU分配给其它就绪进程的调度方式

# NO-7 什么是死锁？产生条件？如何避免死锁？

## 1 什么是死锁？

在两个或者多个并发过程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持的资源，在未改变这种状态之前都不能向前推进，称这一组进程发生了死锁。

死锁产生的原因：系统资源不足， 进程推进顺序非法

通俗地讲，**就是两个或多个进程无限期的阻塞、相互等待的一种状态。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529212227523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

## 2 死锁产生的四个条件

- （1）**互斥条件**
  一个进程每次只能被一个进程使用
  至少有一个资源属于非共享模式，即一次只能被一个进程使用；若其它申请使用该资源，那么申请进程必须等到该资源被释放为止。
- （2）**非抢占（不可剥削条件）**
  进程不能被抢占，即资源只能被进程在完成任务后自愿释放
  进程已获得资源，在未使用完之前，不能被其它进程强制剥夺，只能主动释放
- （3）**占有并等待**（请求和保持条件）
  一个资源必须至少占有一个资源，并等待另一个资源，而该资源为其它进程所占有
  进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被堵塞，但对自己已获得的资源保持不放
- （4）**循环等待**
  若干进程之间形成一种头尾相接的环形等待资源关系
  即进程集合{p0,p1,p2,p3……pn};p0正在等待p1占用的资源，p1正在等待p2占用的资源，pn正在等待p0占用的资源。

只要上面一个条件不成立，就不会发生死锁。

## 3 死锁处理的基本策略和常用方法

解决死锁的基本方法主要有：预防死锁、避免死锁、检测死锁、接触死锁、鸵鸟策略等。

**（1）死锁预防**

死锁预防的基本思想是 **只要保证死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生。**

具体方法包括：

- 打破互斥条件
  允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的
  因此，这种办法通常并无实用价值。
- 打破占有并等待条件
  可以实行资源预先分配策略
  （进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；
  只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程）

或者只允许进程在没有占用资源时才可以申请资源
（一个进程可以申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）

但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性

- 打破非抢占条件
  允许进程强行从占有者哪里夺取某些资源。也就是说，当一个进程占有了一部分资源，在申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。
  这种预防死锁的方式实现起来困难，会降低性能。
- 打破循环等待条件
  实现资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，
  即只有占有了小号资源才能申请大号资源，这样就不会产生环路，预防死锁的产生。

** （2）死锁避免的基本思想**

死锁避免的基本思想是**动态的检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。**
所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的。
换句话说，如果存在一个安全序列，那么系统处于安全状态。
其中，资源分配图算法应用场景为每种资源类型只有一个实例（申请边，分配边，需求变，不形成环才允许分配），
而银行家算法应用于每种资源类型可以有多个实例的场景。

**（3） 死锁解除**
死锁解除的常用两种方法为进程终止和资源抢占。

所谓**进程终止**是指简单的终止一个或多个以打破循环等待，
包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；

所谓**资源抢占**是指从宇哥或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：
a）选择一个牺牲品
b）回滚：回滚到安全状态
c）饥饿（在代价因素上加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚）

------

# NO-8 Windows下的内存是如何管理的

有三种管理方式

- 1 虚拟内存
  最适合用来管理**大型** 对象或结构数组
- 2 内存映射文件
  最适合用来管理大型数据流（通常来自文件） 以及在单个计算机上运行多个进程之间共享数据
- 3 内存堆栈
  最适合用来管理大量的**小对象**

## NO-9 虚拟内存？页面置换算法？

## 1 内存的发展历程

没有内存抽象（单进程，除去操作系统所用的内存之外，全部给用户程序使用）
到
有内存抽象（多进程，进程独立的地址空间，交换技术（内存大小不可能容纳下所有并发执行的进程））
到
连续内存分配（固定大小分区（多道程序的程度受限），可变分区（首次适应，再次适应，最差适应），碎片）
到
不连续内存分配（分段，分页，段页式，虚拟内存）

## 2 虚拟内存

**定义：**具有请求调入和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存和外存之和决定。

虚拟内存允许执行进程不必完全在内存中。
虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页（Page）。
每个页都是一段连续的地址，这些页被映射到物理内存，但是并不是所有的页都必须在内存中才能运行程序。
当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；
当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。

这样，**对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块（称为帧，通常页和帧大小相等），还有一些没家在在内存中的对应在磁盘上。**

如下图所示：

注意：请求分页系统、请求分段系统和请求页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530201909399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTg0ODQ3,size_16,color_FFFFFF,t_70)

由上图可以看出，虚拟内存实际上比物理内存大。
当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如上图中的0，1，2）。
如果虚拟内存的页并不存在于物理内存中（如上图中的3，4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

- **与传统存储器比较虚拟存储器有以下三个主要特征：**
  （1）多次性：是指无需在作业运行时一次性的全部装入内存，而是允许被分成多次调入内存运行
  （2）对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出
  （3）虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量
- **虚拟内存的实现有以下两种方式**
  （1）请求分页存储管理
  （2）请求分段存储管理

## 3 页面置换算法

- FIFO先进先出算法
  在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）
  该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
- LRU（Last recently use） 最近最久使用算法
  根据使用时间到现在的长短来判断
  该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面
- LFU（Least frequently use） 最少使用次数算法
  根据使用次数来判断
  该算法选择最近时期使用最少的页面作为淘汰页
- OPT（Optimal replacement ） 最优置换算法
  理论的最优，理论：就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法

## 4 颠簸（抖动）

颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。
然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。
因此，会不断产生却也中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

内存颠簸的解决策略包括：

- 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题
- 如果是因为允运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则需要降低多道程序的数量
- 否则，还剩下两个办法：终止该进程或增加物理内存容量

## 5 虚拟内存的应用与优点

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。
当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。

虚拟内存的使用可以带来以下好处：

- 在内存中可以保留多个进程，系统并发度提高
- 解除来用户 与内存之间的紧密约束，进程可以比内存的全部空间还大

------

# NO-9 分页和分段有什么区别（内存管理）？

**页**是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的徐需要，而不是用户的需要。

**段** 是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好的满足用户的需要。

**页面存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。**
在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧
程序加载时，可以将任意一夜放入内存中的任意一个帧，这些帧不必连续，从而实现了离散分离。
**页式存储管理的优点是**：没有外碎片（因为页的大小固定），
但会产生内碎片（一个页可能填充不满）。

**段式存储管理是一种符合用户视角的内存分配管理方案。**
在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；
这样每个进程都有一个二维地址空间，相互独立，互不干扰。
**段式管理的优点**是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。
但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

> **两者的不同点**

- **1 目的不同**
  分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位
  分段的目的是为了能更好的满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息
- **2 大小不同**
  页的大小固定且由系统决定，把逻辑地址分为页号和页内地址两部分，由机器硬件实现的。因此一个系统只能有一种大小的页面。
  而段的长度却不固定，由其所完成的功能决定，决定于用户所编写的程序，通常由编写程序在对源代码进行编辑时，根据信息的性质来划分。
- **3 地址空间不同**
  页向用户提供一维地址空间，即单一的线性空间
  段向用户提高二维地址空间，程序员在标识一个地址时，既需要给出段名，又需要给出段内地址。
- **4 信息共享**
  段是信息的逻辑单位，便于存储保护和信息的共享，
  页的保护和共享受到限制
- **5 内存碎片**
  页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）
  而段式存储管理的优点是没有外碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

> 内部碎片与外部碎片
> 在内存管理中，内部碎片是已经被分配出去的内存空间大于请求所需的内存空间
> 外部碎片是指还没有分配出去，但是由于太小而无法分配给申请空间的新进程的内存空间空闲块
> 固定分区存在内部碎片，可变式分区分配会存在外部碎片
> 页面虚拟存储系统存在内部碎片；段式虚拟存储系统，存在外部碎片
> 为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片
> 为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4K的段来放到原来5K的地方，于是形成1K的外部碎片。

# NO-10 同步与异步

## 1 同步

同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，
那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。

特点：
同步是**阻塞** 模式；
同步是**按顺序执行**， 执行完一个再执行下一个，需要等待，协调运行

## 2 异步

异步是指进程不需要一直等下去，而是**继续执行** 下面的操作，不管其他进程的状态。
当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。

特点：
异步是**非阻塞**模式， 无需等待；
异步是**彼此独立**， 在等待某事件的过程中，继续做自己的事，不需要等待这一时间完成后再工作。线程是异步实现的一个方式

## 3 同步和异步优缺点

同步可以避免出现死锁，读脏数据的发生
一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个已经删除了的内容，就会出错，同步就不会出错。

但， 同步需要等待资源访问结束，浪费时间，效率低

异步可以提高效率，但，安全性较低。

# NO-11 中断和轮询

对I/O 设备的程序轮询的方式，是早起的计算机系统对I/O设备的一种管理方式。
它定时对各种设备轮流询问一遍有无处理要求。
轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。
尽管轮询需要时间，但轮询要比I/O设备的速度快得多，所以一般不会发生不能及时处理的问题。
当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的，而且，程序轮询毕竟占据了CPU相当一部分处理时间。
因此，程序轮询是一种效率极低的方式，在现代计算机系统中已很少应用。

程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部时间，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。

轮询—效率低，等待时间很长，CPU利用率不高
中断—容易遗漏一些问题，CPU利用率高

# NO-12 什么是临界区？如何解决冲突？

每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其它进程进入。

- （1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入
- （2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待
- （3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区
- （4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象

# NO-13 Linux中常用的命令

显示文件目录命令 **ls**

改变当前目录命令**cd** 如cd/home

建立子目录 **mkdir** 如mkdir test

删除子目录命令 **rmdir** 如rmdir /mnt/cdrom

删除文件命令 **rm** 如rm /test.xls

文件复制命令**cp** 如 cp /root/test

获取帮助信息命令**man** 如man ls

显示文件的内容 **less** 如less test.txt

重定向与管道 **type** 如type readme >> direct, 将文件readme文件的内容追加到direct中