#### volatile的定义和实现原理

java编程语言循序编程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。java提供了volatile，在某些情况下比锁要更加方便。如果一个字段被生命成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。



#### volatile实现原理

如果对声明了volatile的变量进行了写操作，jvm就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存，同时将其他cpu缓存行里该变量的地址置为无效，当处理器下次访问无效地址的时候，就会重新从内存上面获取这个变量的值。

> 注意：在将数据回写到内存的时候，使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。



#### volatile的使用优化

对于宽高速缓存行为64个字节的处理器，如果队列的头结点和尾结点都不足64字节的话，由于不支持部分填充缓存行，处理器会将他们都读到同一个高速缓存行中，在多处理器下，每个处理器都会缓存同样的头尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存行中的尾结点，而队列的如对和出队操作则需要不停修改头节点和尾结点，所以在多处理器的情况下将严重影响到队列的入队和出队效率。使用追加到64字节的方式来填满高速缓存区的缓存行，避免头结点和尾结点加载到同一缓存行，使头尾节点在修改时不会互相锁定。