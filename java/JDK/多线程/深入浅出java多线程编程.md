- 线程简介

　　进程代表运行中的程序。一个运行的java程序就是一个进程。

　　从操作系统的角度来看，线程是进程中可独立执行的子任务。一个进程可以包含多个线程，同一个进程中的线程共享该进程所申请到的资源，如内存空间和文件句柄等。

　　从JVM的角度来看，线程是进程中的一个组件，它可以看作执行java代码的最小单位。

　　java中的线程可以分为守护线程和用户线程。用户线程会组织jvm的正常停止，即jvm正常停止前应用程序中的所有用户线程必须先停止完毕，否则jvm无法停止。而守护线程则不会影响jvm的正常停止。

- 线程的状态与上下文切换的概念

　　java线程的状态可以通过调用相应thread的getState方法获取。该方法的返回值类型Thread.State是一个枚举类型，包含的状态有以下几种。

1. NEW
   1. 一个刚创建而未启动的线程处于该状态。由于一个线程实例只能被启动一次，因此一个线程只可能有一次处于该状态。　　
2. RUNNABLE
   1. 这是一个复合状态，包括READY和RUNNING。
   2. READY。表示该状态的线程可以被jvm的线程调度器进行调度而使之处于RUNNING状态。
   3. RUNNING。表示该线程正在运行，即相应线程的run方法正在被执行。当Thread实例的yield方法被调用时或由于线程调度器的原因，相应线程的状态会由RUNNING转为READY。　　
3. BLOCKED
   1. 一个线程发起了一个阻塞式io操作后，或者试图去获取以一个由其他线程持有的锁时，相应的线程会处于该状态。处于该状态的线程并不会占用CPU资源。当相应的io操作完成后，或者相应的锁被其他线程释放后，该线程的状态又可以转换为RUNNABLE。
4. WAITING
   1. 一个线程执行了某些方法调用之后就会处于这种无限等待其他线程执行特定操作的状态。这些方法包括：Object.wait()，Thread.join()...能使相应线程从WAITING转换到RUNNABLE的相应方法包括：Object.notify()，Object.notifyAll()...
5. TIMED_WAITING
   1. 与WAITING状态类似，差别在于等待时间非无限等待，指定时间过后，自动转为RUNNABLE。
6. TERMINATED
   1. 已经执行结束的线程处于该状态。同NEW一样，有且仅有一次。run方法正常返回或者由于异常终止都会导致该状态。
7. 上下文切换
   1. 由上述描述可知，一个线程的生命周期中，只可能一次处于NEW和TERMINATED状态。而一个线程的状态从RUNNABLE转换为BLOCKED，WAITING和TIME_WAITING状态中的任意一个都意味着上下文切换。
   2. 上下文切换的场景类似于我们接听手机，我们正在打电话时有另一个电话打进来，我们接听新的电话，而之前的电话就处于等待状态，等新的电话结束之后，我们回过头来与前者重新通话，“我们之前说道哪儿了？”
   3. 线程间的切换，状态变化需要对相应的上下文信息进行保存和恢复，这个过程就被称为上下文切换。
   4. 上下文切换会带来额外的开销，包括保存和恢复线程上下文信息的开销、对线程进行调度的CPU时间开销以及CPU缓存内容失效的开销。
   5. Linux平台下，我们可以使用perf命令来监视上下文切换情况。
   6. Window平台下，我们可以使用Window自带工具perfmon来监视上下文切换情况。

- 线程的监控
  - jvisualvm、jstack、JMC



- synchronized和volatile

- - 了解这两个关键字之前，我们需要先有以下几个概念，原子性、内存可见性和重排序。
  - 原子性。原子操作是指相应的操作是单一不可分割的操作。例如：count++就不是原子操作，因为该操作分为三步，1）读取count的值，2）count做++运算，3）把运算后的值赋予count。在多线程环境下，该操作可能会收到其他线程的干扰，导致我们不能得到想要的结果。
  - 内存可见性。CPU在执行代码的时候，为了减少变量访问的时间消耗，可能会将代码中访问的变量的值缓存到该CPU的缓存区。因此代码访问或者写入的变量，可能只是在缓存区而不是主内存。这就导致了一个CPU对变量的操作可能无法被其他CPU感知。
  - 重排序。编译器和CPU为了提高指令的执行效率可能会进行指令重排序，意思是一段代码的实际执行顺序会被重新排序。例如：People p = new People()；正常地执行流程为：1）创建People的实例，2）将实例赋予变量p。但是由于指令重排的作用，实际实行顺序可能是：1）分配一段用于储存People实例的内存空间，2）将对该空间的引用赋值给变量p，3）创建People的实例。因此，当其他线程访问变量p时，可能此时p实例的初始化尚未完成。
  - synchronized关键字实现操作原子性的本质是通过该关键字所包括的临界区的排他性保证在同一时刻只有一个线程能执行临界区中的代码。该操作保证了原子性和内存可见性。
  - volatile关键字保证了内存可见性，即，一个线程对一个volatile关键字修饰的变量的值的更改对于其他访问该变量的线程总是可见的。其核心机制为当一个线程更改了volatile关键字修饰的变量的值时，该值会被写入主内存而不仅仅时该线程的CPU缓存区，而其他CPU的缓存区中储存的该变量的值就会失效。这就保证了当任意线程访问一个volatile修饰的值时，那一刻得到的值一定是最新的。但是如果在读取后，有线程对其进行了修改，就无法保证操作的原子性了。volatile关键字的另一个作用是它禁止了指令重排序。
  - synchronized关键字技能保证操作的原子性，也能保证内存可见性，但是会导致上下文切换。volatile关键字仅能保证内存可见性。

- 多线程的优点和缺点
  - 优点
  - 提高系统的吞吐量。
  - 提高响应性。一个慢的操作不会影响其他请求的处理。
  - 充分利用多核CPU资源。
  - 最小化对系统资源的使用。一个进程中的多个线程可以共享该进程申请的资源（如内存空间）。
  - 简化程序的结构。
  - 缺点
  - 线程安全问题。多个线程共享数据必然会导致复杂度上升。
  - 线程的生命特征问题。多个线程在交互的过程中会出现无法充分使用线程的生命周期的问题，会导致一定程度上的浪费。
  - 上下文切换问题。频繁的上下文切换会增加对系统的消耗，不利于系统的吞吐量。
  - 可靠性问题。如果一个进程由于某种意外中止了，那么里面所有的线程都无法继续运行。
- 多线程的设计模式
  - 多线程设计模式所解决的问题可以分为以下几类：
    - 不使用锁的情况下保证线程安全
    - 优雅的停止线程
    - 线程协作
    - 提高并发性
    - 提高响应性
    - 减少资源消耗
- 线程池
  - 本来想自己整理，网上看到一篇博客关于线程池也相当细致，就不重复造轮子了，大家可以直接转链接：https://www.cnblogs.com/superfj/p/7544971.html