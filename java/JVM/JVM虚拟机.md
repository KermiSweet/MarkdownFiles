# JVM

java虚拟机(java virtual mechine, JVM)，一种能够运行java字节码的虚拟机，作为一种编程语言的虚拟机，实际上不只是专用于java语言，只要生成的编译文件匹配jvm对价在编译文件格式要求，任何语言都可以由jvm编译运行。比如kotlin，scala等

## JVM的基本结构

JVM主要由三个主要的子系统构成

- 类加载子系统
- 运行时数据区（内存结构）
- 执行引擎

![image-20200316143745571](assets/image-20200316143745571.png)

![image-20200315111610361](assets/image-20200315111610361.png)

## 类加载机制

### 类的生命周期

![image-20200316143840348](assets/image-20200316143840348.png)

#### 1.加载

将`.class`文件从磁盘读到内存

#### 2. 连接

##### 2.1 验证

验证字节码文件的正确性

##### 2.2 准备

给类的静态变量分配内存，并赋予默认值

##### 2.3解析

类装载器装入类所引用的其他所有类

#### 3. 初始化

为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的默认值，执行静态代码块

####  4.使用

#### 5. 卸载

## 类加载器的种类

----

### 启动类加载器(Bootstrap ClassLoader)

负责加载`JRE`的核心类库，如`JRE`目标下的`rt.jar`,`charsets.jar`等

### 扩展类加载器(Extension ClassLoader)

负载加载`JRE`扩展目录`ext`中的jar类包

### 系统类加载器(Application ClassLoader)

负责加载`ClassPath`路径下的类包

### 用户自定义加载器(User ClassLoader)

负责加载用户自定义路径下的类包

![image-20200316163819995](assets/image-20200316163819995.png)

## 类记载机制

----

### 全盘负责委托机制

当一个`ClassLoader`加载一个类的时候，除非显示的使用另一个`ClassLoader`，该类所依赖和引用的类也由这个`ClassLoader`载入

### 双亲委派机制

指先委托父类加载器寻找目标类，在找不到的情况下在自己的路径中查找并载入目标类

#### 双亲委派模式的优势

- 沙箱安全机制：比如自己写的`String.class`类不会被加载，这样就可以防止核心库被随意篡改
- 避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次

# GC算法和收集器

## 如何判断对象可以被回收

堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已近死亡（即不能再被任何途径使用的对象）

### 引用计数法

给对象添加一个引用计数器，每当有一个地方引用，计数器就加1,。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的

这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之间相互循环引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用，但是它们因为相互引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们

```java
public class CounterGC{
    Object instance = null;
    
    public static void main(String[] args){
        CounterGC a = new CounterGC();
        CounterGC b = new CounterGC();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
    }
}
```

### 可达性分析算法

这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路劲称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的



GC Roots根节点： 类加载器、Thread、虚拟机栈的局部变量、static成员、常亮引用，本地方法栈的变量等等

![image-20200316193713290](assets/image-20200316193713290.png)

1. 如何判断一个常量是废弃常量。

2. 运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量是废弃常量呢？
3. 加入在常量池中存在字符串“abc”，如果当前眉头任何String对象引用该字符串常量的话，就说明常量“abc”就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc”会被系统清理出常量池

## 如何判断一个类是无用的类

**需满足以下三个条件：**

- 该类所有的实例都已经回收，也就是Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是“可以”，而并不是和对象一样不适用了就必然会被回收



## 垃圾回收算法

![image-20200316213841513](assets/image-20200316213841513.png)

### 标记-清楚算法

它是最基础的手机算法，这个算法分为两个阶段，“标记”和“清除”。首先标记出所有需要回收的对象，在标记完成后同一回收所有被标记的对象。它有两个不足的地方：

1. 效率问题，标记和清除两个过程的效率都不高
2. 空间问题，标记清除后会产生大量不连续的碎片

![image-20200316214155140](assets/image-20200316214155140.png)

### 复制算法

为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。这样就使毎次的内存回收都是对内存区间的一半进行回收

![image-20200316214238293](assets/image-20200316214238293.png)

### 标记整理算法

根据老年代的特点提岀的一种标记算法，标记过程和“标记清除'算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存

![image-20200316214317384](assets/image-20200316214317384.png)

### 分代收集算法

现在的商用虛拟杋的垃圾收集器基本都采用"分代收集"算法，这种算法就是根据对象存活周期的不同将內存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
在新生代中，毎次收集都有大量对象死去，所以可以选择复制算法，只要付岀少量对象的复制成本就可以完成毎次垃圾收集。而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记清除'或者标记整理"算法进行垃圾收集